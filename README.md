# -BIG-A-_-
# 빅테이터 중간과제

# 1. 정규 표현식 (Regular Expression) 
# 정규 표현식에 대해 조사하고, 본인의 깃허브에 public 프로젝트로 등록하여 정리하시오.
# 정규 표현식이 왜 필요한지, 파이썬에서의 기본 사용법, 코드 예제가 필수로 포함되어야 함 


<!-- 

정규 표현식(Regular Expression)은 문자열 패턴을 표현하기 위한 형식 언어이다. 주어진 문자열에서 특정한 패턴을 찾거나, 패턴에 매칭되는 문자열을 대체하거나 추출하는 등의 작업에 사용된다. 그리고 패턴을 표현하는데 사용되는 메타문자(meta-characters), 특수 문자, 백슬래시 이스케이프(escape) 등을 조합하여 작성된다. 이러한 패턴은 문자의 일치 여부, 반복 횟수, 그룹화 등 다양한 조건을 표현할 수 있다. 

'\d': 숫자에 매칭된다.
'\w': 알파벳 대소문자, 숫자, 밑줄(_)에 매칭 된다.
'+' : 바로 앞의 패턴이 하나 이상의 반복을 의미한다.
'*' : 바로 앞의 패턴이 0개 이상의 반복을 의미한다.
'.' : 임의의 한 문자에 매칭된다. 

-->

# 정규 표현식 파이썬 코드 예제 (전화번호를 추출해야 할 때)

import re

#text = "제 전화번호는 010-1234-5678입니다. 다른 번호로 연락주세요."

pattern = r"\d{3}-\d{4}-\d{4}"  # 전화번호 패턴: 010-1234-5678

result = re.search(pattern, text)

if result:
    phone_number = result.group()
    print("추출된 전화번호:", phone_number)
else:
    print("전화번호를 찾을 수 없습니다.")

<!-- 위의 코드는 주어진 문자열에서 "010-1234-5678"과 같은 전화번호를 추출하는 예제이다. 정규 표현식 패턴 r"\d{3}-\d{4}-\d{4}"을 사용하여 숫자 3개, 하이픈, 숫자 4개, 하이픈, 숫자 4개의 패턴에 매칭되는 전화번호를 찾는다. re.search() 함수를 사용하여 첫 번째로 매칭되는 패턴을 찾고, result.group()을 통해 추출된 전화번호를 가져온다. -->



# 2. 가비지 컬렉션(Garbage Collection)
# GC에 대해 조사하고, 왜 필요하고, 어떤 매커니즘으로 동작되는지(본인이 확실히 이해한 내용을 기술), GC가 제대로 동작되도록 코드를 어떻게 작성해야 하는지 ,어떻게 하면 GC 로도 메모리 leak 이 발생되는지 예제 코드와 함께 설명
<!-- 

가비지 컬렉션은 프로그래밍 언어나 실행 환경에서 메모리 관리를 자동화하는 기술이다. 프로그램이 실행되면서 동적으로 할당된 메모리 공간 중에서 더 이상 사용되지 않는 객체들을 식별하고 해제하는 과정을 말한다.

가비지 컬렉션은 주로 메모리 누수와 관련된 문제를 해결하기 위해 사용되고, 메모리 누수는 프로그램에서 동적으로 할당된 메모리를 해제하지 않고 계속 보유하고 있는 상태를 말한다. 이러한 상황은 메모리 자원의 낭비를 초래하고, 장기적으로는 메모리 부족이나 성능 저하로 이어질 수 있다.

가비지 컬렉션은 다양한 알고리즘과 방식으로 동작할 수 있지만, 대부분의 가비지 컬렉션 시스템은 "도달 가능성"을 기반으로 동작한다. 즉, 프로그램에서 직접적으로 참조되는 객체들은 유효한 객체로 간주되고, 참조되지 않는 객체들은 가비지로 간주된다.
일반적으로 가비지 컬렉션은 다음과 같은 단계로 동작한다.

가비지 컬렉션 시작: 가비지 컬렉션이 실행되는 시점을 결정하고, 실행 환경은 현재 메모리 상태를 분석한다.
도달 가능성 분석: 실행 환경은 프로그램의 시작점으로부터 접근 가능한 객체들을 식별한다. 이러한 객체들은 도달 가능한 객체로 표시된다.
가비지 식별: 도달 가능한 객체 외에 다른 객체들은 가비지로 간주된다.
가비지 수거: 가비지 객체들은 메모리에서 해제되고, 자원을 반환한다.
메모리 정리: 가비지 컬렉션 후에는 메모리를 최적화하거나 조각화하여 재사용 가능한 상태로 만든다.
이렇게 동작하는 가비지 컬렉션은 프로그래머가 명시적으로 메모리 관리를 신경쓰지 않아도 되므로 개발자의 부담을 줄여준다. 하지만 가비지 컬렉션은 자동으로 메모리를 관리하기 때문에 실행 시간에 일시적으로 일시정지되는 "가비지 컬렉션 지연" 현상이 발생할 수 있으며, 이는 실시간 응용 프로그램에는 적합하지 않을 수 있다.

-->


# 가비지 컬렉션 동작을 보여주는 예제 코드 (아래 코드는 가비지 컬렉션에 의해 메모리가 제대로 해제되는 예제입니다)

class MyClass:
    def __init__(self, name):
        self.name = name

# 객체 생성
obj1 = MyClass("Object 1")
obj2 = MyClass("Object 2")

# obj1을 참조하는 변수를 해제
obj1 = None

# 가비지 컬렉션 실행
import gc
gc.collect()

# obj1은 더 이상 참조되지 않으므로 가비지로 처리되고 메모리에서 해제됨

<!-- 
위 예제에서 MyClass라는 클래스를 정의하고, obj1과 obj2라는 두 개의 객체를 생성한다. 그런 다음 obj1을 참조하는 변수를 None으로 설정하여 obj1 객체에 대한 참조를 해제한다. 이후 gc.collect()를 호출하여 가비지 컬렉션을 수동으로 실행한다. 이 때, 가비지 컬렉션은 obj1이 더 이상 참조되지 않는 것을 감지하고, 해당 객체를 메모리에서 해제한다.
-->


# 가비지 컬렉션으로 메모리 leak가 발생할 수 있는 예제

class MyClass:
    def __init__(self):
        self.other = None

# 객체 생성
obj1 = MyClass()
obj2 = MyClass()

# 상호 참조 설정
obj1.other = obj2
obj2.other = obj1

# obj1과 obj2는 서로를 참조하고 있으므로 가비지 컬렉션으로 제거되지 않음

<!-- 
위 예제에서 MyClass 클래스는 other라는 속성을 가지고 있으며, 객체 간에 상호 참조를 설정한다. obj1과 obj2는 서로를 참조하고 있으므로, 더 이상 어떤 변수에서도 접근할 수 없는 상태가 아니다. 이 경우 가비지 컬렉션은 두 객체를 제거하지 않고 남겨둔다. 이는 가비지 컬렉션으로 해결할 수 없는 메모리 leak 상황이다.
-->

# 이런 상황에서는 프로그래머가 명시적으로 상호 참조를 해제해야 한다. 예를 들어, 위 예제에서 다음과 같이 참조를 해제하면 가비지 컬렉션이 동작하여 객체들을 제거한다. 

obj1.other = None
obj2.other = None

# 가비지 컬렉션 실행
import gc
gc.collect()

# obj1과 obj2는 더 이상 서로를 참조하지 않으므로 가비지 컬렉션에 의해 제거됨

# 상호 참조 관계를 해제함으로써 가비지 컬렉션의 대상이 되지 않도록 주의해야 한다. 이를 통해 가비지 컬렉션으로 인한 메모리 leak를 방지할 수 있다.